{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/joesh/OneDrive/Desktop/jammming-project-solution/jammming-project-solution/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/joesh/OneDrive/Desktop/jammming-project-solution/jammming-project-solution/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/joesh/OneDrive/Desktop/jammming-project-solution/jammming-project-solution/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/joesh/OneDrive/Desktop/jammming-project-solution/jammming-project-solution/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncIterator from \"C:/Users/joesh/OneDrive/Desktop/jammming-project-solution/jammming-project-solution/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nvar s = 0;\nvar S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nvar f = 1;\nvar F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nvar LF = 10;\nvar CR = 13;\nvar SPACE = 32;\nvar HYPHEN = 45;\nvar COLON = 58;\nvar A = 97;\nvar Z = 122;\nvar lower = function lower(c) {\n  return c | 0x20;\n};\nvar noop = function noop() {};\nvar MultipartParser = /*#__PURE__*/function () {\n  /**\n   * @param {string} boundary\n   */\n  function MultipartParser(boundary) {\n    _classCallCheck(this, MultipartParser);\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    var ui8a = new Uint8Array(boundary.length);\n    for (var i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _createClass(MultipartParser, [{\n    key: \"write\",\n    value: function write(data) {\n      var _this = this;\n      var i = 0;\n      var length_ = data.length;\n      var previousIndex = this.index;\n      var lookbehind = this.lookbehind,\n        boundary = this.boundary,\n        boundaryChars = this.boundaryChars,\n        index = this.index,\n        state = this.state,\n        flags = this.flags;\n      var boundaryLength = this.boundary.length;\n      var boundaryEnd = boundaryLength - 1;\n      var bufferLength = data.length;\n      var c;\n      var cl;\n      var mark = function mark(name) {\n        _this[name + 'Mark'] = i;\n      };\n      var clear = function clear(name) {\n        delete _this[name + 'Mark'];\n      };\n      var callback = function callback(callbackSymbol, start, end, ui8a) {\n        if (start === undefined || start !== end) {\n          _this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n        }\n      };\n      var dataCallback = function dataCallback(name, clear) {\n        var markSymbol = name + 'Mark';\n        if (!(markSymbol in _this)) {\n          return;\n        }\n        if (clear) {\n          callback(name, _this[markSymbol], i, data);\n          delete _this[markSymbol];\n        } else {\n          callback(name, _this[markSymbol], data.length, data);\n          _this[markSymbol] = 0;\n        }\n      };\n      for (i = 0; i < length_; i++) {\n        c = data[i];\n        switch (state) {\n          case S.START_BOUNDARY:\n            if (index === boundary.length - 2) {\n              if (c === HYPHEN) {\n                flags |= F.LAST_BOUNDARY;\n              } else if (c !== CR) {\n                return;\n              }\n              index++;\n              break;\n            } else if (index - 1 === boundary.length - 2) {\n              if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                state = S.END;\n                flags = 0;\n              } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                index = 0;\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n              } else {\n                return;\n              }\n              break;\n            }\n            if (c !== boundary[index + 2]) {\n              index = -2;\n            }\n            if (c === boundary[index + 2]) {\n              index++;\n            }\n            break;\n          case S.HEADER_FIELD_START:\n            state = S.HEADER_FIELD;\n            mark('onHeaderField');\n            index = 0;\n          // falls through\n          case S.HEADER_FIELD:\n            if (c === CR) {\n              clear('onHeaderField');\n              state = S.HEADERS_ALMOST_DONE;\n              break;\n            }\n            index++;\n            if (c === HYPHEN) {\n              break;\n            }\n            if (c === COLON) {\n              if (index === 1) {\n                // empty header field\n                return;\n              }\n              dataCallback('onHeaderField', true);\n              state = S.HEADER_VALUE_START;\n              break;\n            }\n            cl = lower(c);\n            if (cl < A || cl > Z) {\n              return;\n            }\n            break;\n          case S.HEADER_VALUE_START:\n            if (c === SPACE) {\n              break;\n            }\n            mark('onHeaderValue');\n            state = S.HEADER_VALUE;\n          // falls through\n          case S.HEADER_VALUE:\n            if (c === CR) {\n              dataCallback('onHeaderValue', true);\n              callback('onHeaderEnd');\n              state = S.HEADER_VALUE_ALMOST_DONE;\n            }\n            break;\n          case S.HEADER_VALUE_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n            state = S.HEADER_FIELD_START;\n            break;\n          case S.HEADERS_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n            callback('onHeadersEnd');\n            state = S.PART_DATA_START;\n            break;\n          case S.PART_DATA_START:\n            state = S.PART_DATA;\n            mark('onPartData');\n          // falls through\n          case S.PART_DATA:\n            previousIndex = index;\n            if (index === 0) {\n              // boyer-moore derrived algorithm to safely skip non-boundary data\n              i += boundaryEnd;\n              while (i < bufferLength && !(data[i] in boundaryChars)) {\n                i += boundaryLength;\n              }\n              i -= boundaryEnd;\n              c = data[i];\n            }\n            if (index < boundary.length) {\n              if (boundary[index] === c) {\n                if (index === 0) {\n                  dataCallback('onPartData', true);\n                }\n                index++;\n              } else {\n                index = 0;\n              }\n            } else if (index === boundary.length) {\n              index++;\n              if (c === CR) {\n                // CR = part boundary\n                flags |= F.PART_BOUNDARY;\n              } else if (c === HYPHEN) {\n                // HYPHEN = end boundary\n                flags |= F.LAST_BOUNDARY;\n              } else {\n                index = 0;\n              }\n            } else if (index - 1 === boundary.length) {\n              if (flags & F.PART_BOUNDARY) {\n                index = 0;\n                if (c === LF) {\n                  // unset the PART_BOUNDARY flag\n                  flags &= ~F.PART_BOUNDARY;\n                  callback('onPartEnd');\n                  callback('onPartBegin');\n                  state = S.HEADER_FIELD_START;\n                  break;\n                }\n              } else if (flags & F.LAST_BOUNDARY) {\n                if (c === HYPHEN) {\n                  callback('onPartEnd');\n                  state = S.END;\n                  flags = 0;\n                } else {\n                  index = 0;\n                }\n              } else {\n                index = 0;\n              }\n            }\n            if (index > 0) {\n              // when matching a possible boundary, keep a lookbehind reference\n              // in case it turns out to be a false lead\n              lookbehind[index - 1] = c;\n            } else if (previousIndex > 0) {\n              // if our boundary turned out to be rubbish, the captured lookbehind\n              // belongs to partData\n              var _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n              callback('onPartData', 0, previousIndex, _lookbehind);\n              previousIndex = 0;\n              mark('onPartData');\n\n              // reconsider the current character even so it interrupted the sequence\n              // it could be the beginning of a new sequence\n              i--;\n            }\n            break;\n          case S.END:\n            break;\n          default:\n            throw new Error(\"Unexpected state entered: \".concat(state));\n        }\n      }\n      dataCallback('onHeaderField');\n      dataCallback('onHeaderValue');\n      dataCallback('onPartData');\n\n      // Update properties for the next call\n      this.index = index;\n      this.state = state;\n      this.flags = flags;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n        this.onPartEnd();\n      } else if (this.state !== S.END) {\n        throw new Error('MultipartParser.end(): stream ended unexpectedly');\n      }\n    }\n  }]);\n  return MultipartParser;\n}();\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  var m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n  if (!m) {\n    return;\n  }\n  var match = m[2] || m[3] || '';\n  var filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, function (m, code) {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\nexport function toFormData(_x, _x2) {\n  return _toFormData.apply(this, arguments);\n}\nfunction _toFormData() {\n  _toFormData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(Body, ct) {\n    var m, parser, headerField, headerValue, entryValue, entryName, contentType, filename, entryChunks, formData, onPartData, appendToFile, appendFileToFormData, appendEntryToFormData, decoder, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (/multipart/i.test(ct)) {\n            _context.next = 2;\n            break;\n          }\n          throw new TypeError('Failed to fetch');\n        case 2:\n          m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n          if (m) {\n            _context.next = 5;\n            break;\n          }\n          throw new TypeError('no or bad content-type header, no multipart boundary');\n        case 5:\n          parser = new MultipartParser(m[1] || m[2]);\n          entryChunks = [];\n          formData = new FormData();\n          onPartData = function onPartData(ui8a) {\n            entryValue += decoder.decode(ui8a, {\n              stream: true\n            });\n          };\n          appendToFile = function appendToFile(ui8a) {\n            entryChunks.push(ui8a);\n          };\n          appendFileToFormData = function appendFileToFormData() {\n            var file = new File(entryChunks, filename, {\n              type: contentType\n            });\n            formData.append(entryName, file);\n          };\n          appendEntryToFormData = function appendEntryToFormData() {\n            formData.append(entryName, entryValue);\n          };\n          decoder = new TextDecoder('utf-8');\n          decoder.decode();\n          parser.onPartBegin = function () {\n            parser.onPartData = onPartData;\n            parser.onPartEnd = appendEntryToFormData;\n            headerField = '';\n            headerValue = '';\n            entryValue = '';\n            entryName = '';\n            contentType = '';\n            filename = null;\n            entryChunks.length = 0;\n          };\n          parser.onHeaderField = function (ui8a) {\n            headerField += decoder.decode(ui8a, {\n              stream: true\n            });\n          };\n          parser.onHeaderValue = function (ui8a) {\n            headerValue += decoder.decode(ui8a, {\n              stream: true\n            });\n          };\n          parser.onHeaderEnd = function () {\n            headerValue += decoder.decode();\n            headerField = headerField.toLowerCase();\n            if (headerField === 'content-disposition') {\n              // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n              var _m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n              if (_m) {\n                entryName = _m[2] || _m[3] || '';\n              }\n              filename = _fileName(headerValue);\n              if (filename) {\n                parser.onPartData = appendToFile;\n                parser.onPartEnd = appendFileToFormData;\n              }\n            } else if (headerField === 'content-type') {\n              contentType = headerValue;\n            }\n            headerValue = '';\n            headerField = '';\n          };\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 20;\n          _iterator = _asyncIterator(Body);\n        case 22:\n          _context.next = 24;\n          return _iterator.next();\n        case 24:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 30;\n            break;\n          }\n          chunk = _step.value;\n          parser.write(chunk);\n        case 27:\n          _iteratorAbruptCompletion = false;\n          _context.next = 22;\n          break;\n        case 30:\n          _context.next = 36;\n          break;\n        case 32:\n          _context.prev = 32;\n          _context.t0 = _context[\"catch\"](20);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n        case 36:\n          _context.prev = 36;\n          _context.prev = 37;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context.next = 41;\n            break;\n          }\n          _context.next = 41;\n          return _iterator.return();\n        case 41:\n          _context.prev = 41;\n          if (!_didIteratorError) {\n            _context.next = 44;\n            break;\n          }\n          throw _iteratorError;\n        case 44:\n          return _context.finish(41);\n        case 45:\n          return _context.finish(36);\n        case 46:\n          parser.end();\n          return _context.abrupt(\"return\", formData);\n        case 48:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[20, 32, 36, 46], [37,, 41, 45]]);\n  }));\n  return _toFormData.apply(this, arguments);\n}","map":{"version":3,"names":["File","FormData","s","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","noop","MultipartParser","boundary","_classCallCheck","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","_createClass","key","value","write","data","_this","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","concat","_fileName","headerValue","m","match","filename","slice","lastIndexOf","replace","code","String","fromCharCode","toFormData","_x","_x2","_toFormData","apply","arguments","_asyncToGenerator","_regeneratorRuntime","_callee","Body","ct","parser","headerField","entryValue","entryName","contentType","entryChunks","formData","appendToFile","appendFileToFormData","appendEntryToFormData","decoder","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","wrap","_callee$","_context","prev","next","test","TypeError","decode","stream","push","file","type","append","TextDecoder","toLowerCase","_asyncIterator","sent","done","t0","return","finish","abrupt","stop"],"sources":["C:/Users/joesh/OneDrive/Desktop/jammming-project-solution/jammming-project-solution/node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"mappings":";;;;;AAAA,SAAQA,IAAI,QAAO,oBAAoB;AACvC,SAAQC,QAAQ,QAAO,8BAA8B;AAErD,IAAIC,CAAC,GAAG,CAAC;AACT,IAAMC,CAAC,GAAG;EACTC,cAAc,EAAEF,CAAC,EAAE;EACnBG,kBAAkB,EAAEH,CAAC,EAAE;EACvBI,YAAY,EAAEJ,CAAC,EAAE;EACjBK,kBAAkB,EAAEL,CAAC,EAAE;EACvBM,YAAY,EAAEN,CAAC,EAAE;EACjBO,wBAAwB,EAAEP,CAAC,EAAE;EAC7BQ,mBAAmB,EAAER,CAAC,EAAE;EACxBS,eAAe,EAAET,CAAC,EAAE;EACpBU,SAAS,EAAEV,CAAC,EAAE;EACdW,GAAG,EAAEX,CAAC;AACP,CAAC;AAED,IAAIY,CAAC,GAAG,CAAC;AACT,IAAMC,CAAC,GAAG;EACTC,aAAa,EAAEF,CAAC;EAChBG,aAAa,EAAEH,CAAC,IAAI;AACrB,CAAC;AAED,IAAMI,EAAE,GAAG,EAAE;AACb,IAAMC,EAAE,GAAG,EAAE;AACb,IAAMC,KAAK,GAAG,EAAE;AAChB,IAAMC,MAAM,GAAG,EAAE;AACjB,IAAMC,KAAK,GAAG,EAAE;AAChB,IAAMC,CAAC,GAAG,EAAE;AACZ,IAAMC,CAAC,GAAG,GAAG;AAEb,IAAMC,KAAK,GAAG,SAARA,KAAKA,CAAGC,CAAC;EAAA,OAAIA,CAAC,GAAG,IAAI;AAAA;AAE3B,IAAMC,IAAI,GAAG,SAAPA,IAAIA,CAAA,EAAS,CAAC,CAAC;AAAC,IAEhBC,eAAe;EACpB;AACD;AACA;EACC,SAAAA,gBAAYC,QAAQ,EAAE;IAAAC,eAAA,OAAAF,eAAA;IACrB,IAAI,CAACG,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,KAAK,GAAG,CAAC;IAEd,IAAI,CAACC,WAAW,GAAGN,IAAI;IACvB,IAAI,CAACO,aAAa,GAAGP,IAAI;IACzB,IAAI,CAACQ,YAAY,GAAGR,IAAI;IACxB,IAAI,CAACS,aAAa,GAAGT,IAAI;IACzB,IAAI,CAACU,WAAW,GAAGV,IAAI;IACvB,IAAI,CAACW,UAAU,GAAGX,IAAI;IACtB,IAAI,CAACY,SAAS,GAAGZ,IAAI;IAErB,IAAI,CAACa,aAAa,GAAG,CAAC,CAAC;IAEvBX,QAAQ,GAAG,QAAQ,GAAGA,QAAQ;IAC9B,IAAMY,IAAI,GAAG,IAAIC,UAAU,CAACb,QAAQ,CAACc,MAAM,CAAC;IAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,QAAQ,CAACc,MAAM,EAAEC,CAAC,EAAE,EAAE;MACzCH,IAAI,CAACG,CAAC,CAAC,GAAGf,QAAQ,CAACgB,UAAU,CAACD,CAAC,CAAC;MAChC,IAAI,CAACJ,aAAa,CAACC,IAAI,CAACG,CAAC,CAAC,CAAC,GAAG,IAAI;IACnC;IAEA,IAAI,CAACf,QAAQ,GAAGY,IAAI;IACpB,IAAI,CAACK,UAAU,GAAG,IAAIJ,UAAU,CAAC,IAAI,CAACb,QAAQ,CAACc,MAAM,GAAG,CAAC,CAAC;IAC1D,IAAI,CAACI,KAAK,GAAG5C,CAAC,CAACC,cAAc;EAC9B;;EAEA;AACD;AACA;EAFC4C,YAAA,CAAApB,eAAA;IAAAqB,GAAA;IAAAC,KAAA,EAGA,SAAAC,MAAMC,IAAI,EAAE;MAAA,IAAAC,KAAA;MACX,IAAIT,CAAC,GAAG,CAAC;MACT,IAAMU,OAAO,GAAGF,IAAI,CAACT,MAAM;MAC3B,IAAIY,aAAa,GAAG,IAAI,CAACxB,KAAK;MAC9B,IAAKe,UAAU,GAAkD,IAAI,CAAhEA,UAAU;QAAEjB,QAAQ,GAAwC,IAAI,CAApDA,QAAQ;QAAEW,aAAa,GAAyB,IAAI,CAA1CA,aAAa;QAAET,KAAK,GAAkB,IAAI,CAA3BA,KAAK;QAAEgB,KAAK,GAAW,IAAI,CAApBA,KAAK;QAAEf,KAAK,GAAI,IAAI,CAAbA,KAAK;MAC7D,IAAMwB,cAAc,GAAG,IAAI,CAAC3B,QAAQ,CAACc,MAAM;MAC3C,IAAMc,WAAW,GAAGD,cAAc,GAAG,CAAC;MACtC,IAAME,YAAY,GAAGN,IAAI,CAACT,MAAM;MAChC,IAAIjB,CAAC;MACL,IAAIiC,EAAE;MAEN,IAAMC,IAAI,GAAG,SAAPA,IAAIA,CAAGC,IAAI,EAAI;QACpBR,KAAI,CAACQ,IAAI,GAAG,MAAM,CAAC,GAAGjB,CAAC;MACxB,CAAC;MAED,IAAMkB,KAAK,GAAG,SAARA,KAAKA,CAAGD,IAAI,EAAI;QACrB,OAAOR,KAAI,CAACQ,IAAI,GAAG,MAAM,CAAC;MAC3B,CAAC;MAED,IAAME,QAAQ,GAAG,SAAXA,QAAQA,CAAIC,cAAc,EAAEC,KAAK,EAAEC,GAAG,EAAEzB,IAAI,EAAK;QACtD,IAAIwB,KAAK,KAAKE,SAAS,IAAIF,KAAK,KAAKC,GAAG,EAAE;UACzCb,KAAI,CAACW,cAAc,CAAC,CAACvB,IAAI,IAAIA,IAAI,CAAC2B,QAAQ,CAACH,KAAK,EAAEC,GAAG,CAAC,CAAC;QACxD;MACD,CAAC;MAED,IAAMG,YAAY,GAAG,SAAfA,YAAYA,CAAIR,IAAI,EAAEC,KAAK,EAAK;QACrC,IAAMQ,UAAU,GAAGT,IAAI,GAAG,MAAM;QAChC,IAAI,EAAES,UAAU,IAAIjB,KAAI,CAAC,EAAE;UAC1B;QACD;QAEA,IAAIS,KAAK,EAAE;UACVC,QAAQ,CAACF,IAAI,EAAER,KAAI,CAACiB,UAAU,CAAC,EAAE1B,CAAC,EAAEQ,IAAI,CAAC;UACzC,OAAOC,KAAI,CAACiB,UAAU,CAAC;QACxB,CAAC,MAAM;UACNP,QAAQ,CAACF,IAAI,EAAER,KAAI,CAACiB,UAAU,CAAC,EAAElB,IAAI,CAACT,MAAM,EAAES,IAAI,CAAC;UACnDC,KAAI,CAACiB,UAAU,CAAC,GAAG,CAAC;QACrB;MACD,CAAC;MAED,KAAK1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,OAAO,EAAEV,CAAC,EAAE,EAAE;QAC7BlB,CAAC,GAAG0B,IAAI,CAACR,CAAC,CAAC;QAEX,QAAQG,KAAK;UACZ,KAAK5C,CAAC,CAACC,cAAc;YACpB,IAAI2B,KAAK,KAAKF,QAAQ,CAACc,MAAM,GAAG,CAAC,EAAE;cAClC,IAAIjB,CAAC,KAAKL,MAAM,EAAE;gBACjBW,KAAK,IAAIjB,CAAC,CAACE,aAAa;cACzB,CAAC,MAAM,IAAIS,CAAC,KAAKP,EAAE,EAAE;gBACpB;cACD;cAEAY,KAAK,EAAE;cACP;YACD,CAAC,MAAM,IAAIA,KAAK,GAAG,CAAC,KAAKF,QAAQ,CAACc,MAAM,GAAG,CAAC,EAAE;cAC7C,IAAIX,KAAK,GAAGjB,CAAC,CAACE,aAAa,IAAIS,CAAC,KAAKL,MAAM,EAAE;gBAC5C0B,KAAK,GAAG5C,CAAC,CAACU,GAAG;gBACbmB,KAAK,GAAG,CAAC;cACV,CAAC,MAAM,IAAI,EAAEA,KAAK,GAAGjB,CAAC,CAACE,aAAa,CAAC,IAAIS,CAAC,KAAKR,EAAE,EAAE;gBAClDa,KAAK,GAAG,CAAC;gBACTgC,QAAQ,CAAC,aAAa,CAAC;gBACvBhB,KAAK,GAAG5C,CAAC,CAACE,kBAAkB;cAC7B,CAAC,MAAM;gBACN;cACD;cAEA;YACD;YAEA,IAAIqB,CAAC,KAAKG,QAAQ,CAACE,KAAK,GAAG,CAAC,CAAC,EAAE;cAC9BA,KAAK,GAAG,CAAC,CAAC;YACX;YAEA,IAAIL,CAAC,KAAKG,QAAQ,CAACE,KAAK,GAAG,CAAC,CAAC,EAAE;cAC9BA,KAAK,EAAE;YACR;YAEA;UACD,KAAK5B,CAAC,CAACE,kBAAkB;YACxB0C,KAAK,GAAG5C,CAAC,CAACG,YAAY;YACtBsD,IAAI,CAAC,eAAe,CAAC;YACrB7B,KAAK,GAAG,CAAC;UACT;UACD,KAAK5B,CAAC,CAACG,YAAY;YAClB,IAAIoB,CAAC,KAAKP,EAAE,EAAE;cACb2C,KAAK,CAAC,eAAe,CAAC;cACtBf,KAAK,GAAG5C,CAAC,CAACO,mBAAmB;cAC7B;YACD;YAEAqB,KAAK,EAAE;YACP,IAAIL,CAAC,KAAKL,MAAM,EAAE;cACjB;YACD;YAEA,IAAIK,CAAC,KAAKJ,KAAK,EAAE;cAChB,IAAIS,KAAK,KAAK,CAAC,EAAE;gBAChB;gBACA;cACD;cAEAsC,YAAY,CAAC,eAAe,EAAE,IAAI,CAAC;cACnCtB,KAAK,GAAG5C,CAAC,CAACI,kBAAkB;cAC5B;YACD;YAEAoD,EAAE,GAAGlC,KAAK,CAACC,CAAC,CAAC;YACb,IAAIiC,EAAE,GAAGpC,CAAC,IAAIoC,EAAE,GAAGnC,CAAC,EAAE;cACrB;YACD;YAEA;UACD,KAAKrB,CAAC,CAACI,kBAAkB;YACxB,IAAImB,CAAC,KAAKN,KAAK,EAAE;cAChB;YACD;YAEAwC,IAAI,CAAC,eAAe,CAAC;YACrBb,KAAK,GAAG5C,CAAC,CAACK,YAAY;UACtB;UACD,KAAKL,CAAC,CAACK,YAAY;YAClB,IAAIkB,CAAC,KAAKP,EAAE,EAAE;cACbkD,YAAY,CAAC,eAAe,EAAE,IAAI,CAAC;cACnCN,QAAQ,CAAC,aAAa,CAAC;cACvBhB,KAAK,GAAG5C,CAAC,CAACM,wBAAwB;YACnC;YAEA;UACD,KAAKN,CAAC,CAACM,wBAAwB;YAC9B,IAAIiB,CAAC,KAAKR,EAAE,EAAE;cACb;YACD;YAEA6B,KAAK,GAAG5C,CAAC,CAACE,kBAAkB;YAC5B;UACD,KAAKF,CAAC,CAACO,mBAAmB;YACzB,IAAIgB,CAAC,KAAKR,EAAE,EAAE;cACb;YACD;YAEA6C,QAAQ,CAAC,cAAc,CAAC;YACxBhB,KAAK,GAAG5C,CAAC,CAACQ,eAAe;YACzB;UACD,KAAKR,CAAC,CAACQ,eAAe;YACrBoC,KAAK,GAAG5C,CAAC,CAACS,SAAS;YACnBgD,IAAI,CAAC,YAAY,CAAC;UAClB;UACD,KAAKzD,CAAC,CAACS,SAAS;YACf2C,aAAa,GAAGxB,KAAK;YAErB,IAAIA,KAAK,KAAK,CAAC,EAAE;cAChB;cACAa,CAAC,IAAIa,WAAW;cAChB,OAAOb,CAAC,GAAGc,YAAY,IAAI,EAAEN,IAAI,CAACR,CAAC,CAAC,IAAIJ,aAAa,CAAC,EAAE;gBACvDI,CAAC,IAAIY,cAAc;cACpB;cAEAZ,CAAC,IAAIa,WAAW;cAChB/B,CAAC,GAAG0B,IAAI,CAACR,CAAC,CAAC;YACZ;YAEA,IAAIb,KAAK,GAAGF,QAAQ,CAACc,MAAM,EAAE;cAC5B,IAAId,QAAQ,CAACE,KAAK,CAAC,KAAKL,CAAC,EAAE;gBAC1B,IAAIK,KAAK,KAAK,CAAC,EAAE;kBAChBsC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC;gBACjC;gBAEAtC,KAAK,EAAE;cACR,CAAC,MAAM;gBACNA,KAAK,GAAG,CAAC;cACV;YACD,CAAC,MAAM,IAAIA,KAAK,KAAKF,QAAQ,CAACc,MAAM,EAAE;cACrCZ,KAAK,EAAE;cACP,IAAIL,CAAC,KAAKP,EAAE,EAAE;gBACb;gBACAa,KAAK,IAAIjB,CAAC,CAACC,aAAa;cACzB,CAAC,MAAM,IAAIU,CAAC,KAAKL,MAAM,EAAE;gBACxB;gBACAW,KAAK,IAAIjB,CAAC,CAACE,aAAa;cACzB,CAAC,MAAM;gBACNc,KAAK,GAAG,CAAC;cACV;YACD,CAAC,MAAM,IAAIA,KAAK,GAAG,CAAC,KAAKF,QAAQ,CAACc,MAAM,EAAE;cACzC,IAAIX,KAAK,GAAGjB,CAAC,CAACC,aAAa,EAAE;gBAC5Be,KAAK,GAAG,CAAC;gBACT,IAAIL,CAAC,KAAKR,EAAE,EAAE;kBACb;kBACAc,KAAK,IAAI,CAACjB,CAAC,CAACC,aAAa;kBACzB+C,QAAQ,CAAC,WAAW,CAAC;kBACrBA,QAAQ,CAAC,aAAa,CAAC;kBACvBhB,KAAK,GAAG5C,CAAC,CAACE,kBAAkB;kBAC5B;gBACD;cACD,CAAC,MAAM,IAAI2B,KAAK,GAAGjB,CAAC,CAACE,aAAa,EAAE;gBACnC,IAAIS,CAAC,KAAKL,MAAM,EAAE;kBACjB0C,QAAQ,CAAC,WAAW,CAAC;kBACrBhB,KAAK,GAAG5C,CAAC,CAACU,GAAG;kBACbmB,KAAK,GAAG,CAAC;gBACV,CAAC,MAAM;kBACND,KAAK,GAAG,CAAC;gBACV;cACD,CAAC,MAAM;gBACNA,KAAK,GAAG,CAAC;cACV;YACD;YAEA,IAAIA,KAAK,GAAG,CAAC,EAAE;cACd;cACA;cACAe,UAAU,CAACf,KAAK,GAAG,CAAC,CAAC,GAAGL,CAAC;YAC1B,CAAC,MAAM,IAAI6B,aAAa,GAAG,CAAC,EAAE;cAC7B;cACA;cACA,IAAMgB,WAAW,GAAG,IAAI7B,UAAU,CAACI,UAAU,CAAC0B,MAAM,EAAE1B,UAAU,CAAC2B,UAAU,EAAE3B,UAAU,CAAC4B,UAAU,CAAC;cACnGX,QAAQ,CAAC,YAAY,EAAE,CAAC,EAAER,aAAa,EAAEgB,WAAW,CAAC;cACrDhB,aAAa,GAAG,CAAC;cACjBK,IAAI,CAAC,YAAY,CAAC;;cAElB;cACA;cACAhB,CAAC,EAAE;YACJ;YAEA;UACD,KAAKzC,CAAC,CAACU,GAAG;YACT;UACD;YACC,MAAM,IAAI8D,KAAK,8BAAAC,MAAA,CAA8B7B,KAAK,EAAG;QAAC;MAEzD;MAEAsB,YAAY,CAAC,eAAe,CAAC;MAC7BA,YAAY,CAAC,eAAe,CAAC;MAC7BA,YAAY,CAAC,YAAY,CAAC;;MAE1B;MACA,IAAI,CAACtC,KAAK,GAAGA,KAAK;MAClB,IAAI,CAACgB,KAAK,GAAGA,KAAK;MAClB,IAAI,CAACf,KAAK,GAAGA,KAAK;IACnB;EAAC;IAAAiB,GAAA;IAAAC,KAAA,EAED,SAAAgB,IAAA,EAAM;MACL,IAAK,IAAI,CAACnB,KAAK,KAAK5C,CAAC,CAACE,kBAAkB,IAAI,IAAI,CAAC0B,KAAK,KAAK,CAAC,IAC1D,IAAI,CAACgB,KAAK,KAAK5C,CAAC,CAACS,SAAS,IAAI,IAAI,CAACmB,KAAK,KAAK,IAAI,CAACF,QAAQ,CAACc,MAAO,EAAE;QACrE,IAAI,CAACJ,SAAS,EAAE;MACjB,CAAC,MAAM,IAAI,IAAI,CAACQ,KAAK,KAAK5C,CAAC,CAACU,GAAG,EAAE;QAChC,MAAM,IAAI8D,KAAK,CAAC,kDAAkD,CAAC;MACpE;IACD;EAAC;EAAA,OAAA/C,eAAA;AAAA;AAGF,SAASiD,SAASA,CAACC,WAAW,EAAE;EAC/B;EACA,IAAMC,CAAC,GAAGD,WAAW,CAACE,KAAK,CAAC,4DAA4D,CAAC;EACzF,IAAI,CAACD,CAAC,EAAE;IACP;EACD;EAEA,IAAMC,KAAK,GAAGD,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EAChC,IAAIE,QAAQ,GAAGD,KAAK,CAACE,KAAK,CAACF,KAAK,CAACG,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;EACvDF,QAAQ,GAAGA,QAAQ,CAACG,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;EACxCH,QAAQ,GAAGA,QAAQ,CAACG,OAAO,CAAC,aAAa,EAAE,UAACL,CAAC,EAAEM,IAAI,EAAK;IACvD,OAAOC,MAAM,CAACC,YAAY,CAACF,IAAI,CAAC;EACjC,CAAC,CAAC;EACF,OAAOJ,QAAQ;AAChB;AAEA,gBAAsBO,UAAUA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,WAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAgG/B,SAAAF,YAAA;EAAAA,WAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAnC,IAAA,CAhGM,SAAAoC,QAA0BC,IAAI,EAAEC,EAAE;IAAA,IAAAnB,CAAA,EAAAoB,MAAA,EAAAC,WAAA,EAAAtB,WAAA,EAAAuB,UAAA,EAAAC,SAAA,EAAAC,WAAA,EAAAtB,QAAA,EAAAuB,WAAA,EAAAC,QAAA,EAAAnE,UAAA,EAAAoE,YAAA,EAAAC,oBAAA,EAAAC,qBAAA,EAAAC,OAAA,EAAAC,yBAAA,EAAAC,iBAAA,EAAAC,cAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAC,KAAA;IAAA,OAAApB,mBAAA,GAAAqB,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,IACnC,YAAY,CAACC,IAAI,CAACvB,EAAE,CAAC;YAAAoB,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACnB,IAAIE,SAAS,CAAC,iBAAiB,CAAC;QAAA;UAGjC3C,CAAC,GAAGmB,EAAE,CAAClB,KAAK,CAAC,iCAAiC,CAAC;UAAA,IAEhDD,CAAC;YAAAuC,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACC,IAAIE,SAAS,CAAC,sDAAsD,CAAC;QAAA;UAGtEvB,MAAM,GAAG,IAAIvE,eAAe,CAACmD,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAAC;UAQ1CyB,WAAW,GAAG,EAAE;UAChBC,QAAQ,GAAG,IAAIxG,QAAQ,EAAE;UAEzBqC,UAAU,GAAG,SAAbA,UAAUA,CAAGG,IAAI,EAAI;YAC1B4D,UAAU,IAAIQ,OAAO,CAACc,MAAM,CAAClF,IAAI,EAAE;cAACmF,MAAM,EAAE;YAAI,CAAC,CAAC;UACnD,CAAC;UAEKlB,YAAY,GAAG,SAAfA,YAAYA,CAAGjE,IAAI,EAAI;YAC5B+D,WAAW,CAACqB,IAAI,CAACpF,IAAI,CAAC;UACvB,CAAC;UAEKkE,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAA,EAAS;YAClC,IAAMmB,IAAI,GAAG,IAAI9H,IAAI,CAACwG,WAAW,EAAEvB,QAAQ,EAAE;cAAC8C,IAAI,EAAExB;YAAW,CAAC,CAAC;YACjEE,QAAQ,CAACuB,MAAM,CAAC1B,SAAS,EAAEwB,IAAI,CAAC;UACjC,CAAC;UAEKlB,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAA,EAAS;YACnCH,QAAQ,CAACuB,MAAM,CAAC1B,SAAS,EAAED,UAAU,CAAC;UACvC,CAAC;UAEKQ,OAAO,GAAG,IAAIoB,WAAW,CAAC,OAAO,CAAC;UACxCpB,OAAO,CAACc,MAAM,EAAE;UAEhBxB,MAAM,CAAC9D,WAAW,GAAG,YAAY;YAChC8D,MAAM,CAAC7D,UAAU,GAAGA,UAAU;YAC9B6D,MAAM,CAAC5D,SAAS,GAAGqE,qBAAqB;YAExCR,WAAW,GAAG,EAAE;YAChBtB,WAAW,GAAG,EAAE;YAChBuB,UAAU,GAAG,EAAE;YACfC,SAAS,GAAG,EAAE;YACdC,WAAW,GAAG,EAAE;YAChBtB,QAAQ,GAAG,IAAI;YACfuB,WAAW,CAAC7D,MAAM,GAAG,CAAC;UACvB,CAAC;UAEDwD,MAAM,CAACjE,aAAa,GAAG,UAAUO,IAAI,EAAE;YACtC2D,WAAW,IAAIS,OAAO,CAACc,MAAM,CAAClF,IAAI,EAAE;cAACmF,MAAM,EAAE;YAAI,CAAC,CAAC;UACpD,CAAC;UAEDzB,MAAM,CAAC/D,aAAa,GAAG,UAAUK,IAAI,EAAE;YACtCqC,WAAW,IAAI+B,OAAO,CAACc,MAAM,CAAClF,IAAI,EAAE;cAACmF,MAAM,EAAE;YAAI,CAAC,CAAC;UACpD,CAAC;UAEDzB,MAAM,CAAClE,WAAW,GAAG,YAAY;YAChC6C,WAAW,IAAI+B,OAAO,CAACc,MAAM,EAAE;YAC/BvB,WAAW,GAAGA,WAAW,CAAC8B,WAAW,EAAE;YAEvC,IAAI9B,WAAW,KAAK,qBAAqB,EAAE;cAC1C;cACA,IAAMrB,EAAC,GAAGD,WAAW,CAACE,KAAK,CAAC,mDAAmD,CAAC;cAEhF,IAAID,EAAC,EAAE;gBACNuB,SAAS,GAAGvB,EAAC,CAAC,CAAC,CAAC,IAAIA,EAAC,CAAC,CAAC,CAAC,IAAI,EAAE;cAC/B;cAEAE,QAAQ,GAAGJ,SAAS,CAACC,WAAW,CAAC;cAEjC,IAAIG,QAAQ,EAAE;gBACbkB,MAAM,CAAC7D,UAAU,GAAGoE,YAAY;gBAChCP,MAAM,CAAC5D,SAAS,GAAGoE,oBAAoB;cACxC;YACD,CAAC,MAAM,IAAIP,WAAW,KAAK,cAAc,EAAE;cAC1CG,WAAW,GAAGzB,WAAW;YAC1B;YAEAA,WAAW,GAAG,EAAE;YAChBsB,WAAW,GAAG,EAAE;UACjB,CAAC;UAACU,yBAAA;UAAAC,iBAAA;UAAAO,QAAA,CAAAC,IAAA;UAAAN,SAAA,GAAAkB,cAAA,CAEwBlC,IAAI;QAAA;UAAAqB,QAAA,CAAAE,IAAA;UAAA,OAAAP,SAAA,CAAAO,IAAA;QAAA;UAAA,MAAAV,yBAAA,KAAAI,KAAA,GAAAI,QAAA,CAAAc,IAAA,EAAAC,IAAA;YAAAf,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAbL,KAAK,GAAAD,KAAA,CAAAhE,KAAA;UACrBiD,MAAM,CAAChD,KAAK,CAACgE,KAAK,CAAC;QAAC;UAAAL,yBAAA;UAAAQ,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAAF,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAgB,EAAA,GAAAhB,QAAA;UAAAP,iBAAA;UAAAC,cAAA,GAAAM,QAAA,CAAAgB,EAAA;QAAA;UAAAhB,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAC,IAAA;UAAA,MAAAT,yBAAA,IAAAG,SAAA,CAAAsB,MAAA;YAAAjB,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OAAAP,SAAA,CAAAsB,MAAA;QAAA;UAAAjB,QAAA,CAAAC,IAAA;UAAA,KAAAR,iBAAA;YAAAO,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MAAAR,cAAA;QAAA;UAAA,OAAAM,QAAA,CAAAkB,MAAA;QAAA;UAAA,OAAAlB,QAAA,CAAAkB,MAAA;QAAA;UAGrBrC,MAAM,CAACjC,GAAG,EAAE;UAAC,OAAAoD,QAAA,CAAAmB,MAAA,WAENhC,QAAQ;QAAA;QAAA;UAAA,OAAAa,QAAA,CAAAoB,IAAA;MAAA;IAAA,GAAA1C,OAAA;EAAA,CACf;EAAA,OAAAL,WAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}